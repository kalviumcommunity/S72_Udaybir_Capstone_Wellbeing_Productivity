var e=Object.defineProperty,t=Object.defineProperties,r=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,a=(t,r,o)=>r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[r]=o,i=(e,t,r)=>a(e,"symbol"!=typeof t?t+"":t,r),c=(e,t,r)=>new Promise((o,n)=>{var s=e=>{try{i(r.next(e))}catch(t){n(t)}},a=e=>{try{i(r.throw(e))}catch(t){n(t)}},i=e=>e.done?o(e.value):Promise.resolve(e.value).then(s,a);i((r=r.apply(e,t)).next())});const l=new class{constructor(){i(this,"TOKEN_KEY","csrf_token"),i(this,"API_BASE_URL","http://localhost:8000/api")}fetchToken(){return c(this,null,function*(){try{const e=yield fetch(`${this.API_BASE_URL}/csrf-token`);if(!e.ok)throw new Error("Failed to fetch CSRF token");const{csrfToken:t}=yield e.json();return t}catch(e){return console.warn("Failed to fetch CSRF token from backend:",e),this.generateFallbackToken()}})}generateFallbackToken(){const e=new Uint8Array(32);return(e=>{if("undefined"!=typeof crypto&&crypto.getRandomValues)return crypto.getRandomValues(e);for(let t=0;t<e.length;t++)e[t]=Math.floor(256*Math.random())})(e),Array.from(e,e=>e.toString(16).padStart(2,"0")).join("")}getToken(){return c(this,null,function*(){let e=sessionStorage.getItem(this.TOKEN_KEY);return e||(e=yield this.fetchToken(),sessionStorage.setItem(this.TOKEN_KEY,e)),e})}validateToken(e){return sessionStorage.getItem(this.TOKEN_KEY)===e}clearToken(){sessionStorage.removeItem(this.TOKEN_KEY)}addTokenToHeaders(){return c(this,arguments,function*(e={}){const i=yield this.getToken();return c=((e,t)=>{for(var r in t||(t={}))n.call(t,r)&&a(e,r,t[r]);if(o)for(var r of o(t))s.call(t,r)&&a(e,r,t[r]);return e})({},e),t(c,r({"X-CSRF-Token":i}));var c})}refreshToken(){return c(this,null,function*(){const e=yield this.fetchToken();return sessionStorage.setItem(this.TOKEN_KEY,e),e})}};export{l as csrfProtection};
